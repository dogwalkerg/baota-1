import{c as e,r as a,h as l,i as t,o as r,k as c,l as o,e as i,x as s,p as m,I as u,aX as p,C as d,D as n,q as h,y as _,v,ag as k,ah as f,a7 as w,a4 as b}from"./base-lib.js?v=1734676359";import{Q as g,G as j,j as V,b as y,e as D}from"./utils-lib.js?v=1734676359";import{groupProjectConfig as x}from"./site.js?v=1734676359";import"./__commonjsHelpers__.js?v=1734676359";const E={class:"p-[2rem]"},q={class:"flex items-center mt-[1.6rem] ml-[3rem]"},U={class:"mt-[1.6rem] leading-8 text-[1.2rem] list-disc ml-[2rem]"},C=D(e({__name:"project-check",props:{compData:{default:{}}},setup(e,{expose:D}){const C=e,I=y(),N=a(),A=a(!1),F=l({check:"a;;",port:"",wait_time:180}),G={check:{required:!0,message:"请输入检测策略",trigger:"blur"},port:[{validator:(e,a,l)=>{a.split(",").filter((e=>""!==e)).some((e=>!g(e)))&&"port"==F.check?l(new Error("请输入正确的端口")):l()}}],wait_time:[{validator:(e,a,l)=>{a<=0&&"active"==F.check||""==a&&"active"==F.check?l(new Error("请输入正确的进程存活时长")):l()}}]},H=[{value:"all",label:"任意端口监听"},{value:"port",label:"指定端口监听"},{value:"active",label:"进程存活时长"}],J=t((()=>{switch(F.check){case"all":return"任意端口监听策略，执行启动后,项目进程直到出现任意一个端口监听后, 才认定为启动成功,最大默认等待3分钟";case"port":return"指定端口监听策略，执行启动后，项目进程直到监听【".concat(F.port,"】端口后，才认定为启动成功,最大默认等待3分钟");case"active":return"进程存活时长，解释:启动该项目后，在【".concat(F.wait_time,"】秒内自动退出则认定为启动成功");default:return""}}));return r((()=>{var e,a,l,t,r;e=C.compData,F.check=(null==(a=e.check_info)?void 0:a.type)||"all","port"===F.check&&0==(null==(l=e.check_info)?void 0:l.port.length)&&(F.check="all"),F.port=(null==(t=e.check_info)?void 0:t.port.join(","))||"",F.wait_time=Number((null==(r=e.check_info)?void 0:r.wait_time)||180)})),D({onConfirm:async e=>{if("active"==F.check&&(F.wait_time<=0||""==F.wait_time))return I.error("请输入正确的进程存活时长");await N.value.validate(),j({loading:A,request:x({group_id:C.compData.group_id,project_id:C.compData.id,check_info:JSON.stringify({type:"all"==F.check?"port":F.check,port:"port"==F.check?F.port.split(","):[],wait_time:"active"==F.check?F.wait_time:180})}),success:a=>{a.status&&(C.compData.refreshEvent&&C.compData.refreshEvent(),e&&e())}})}}),(e,a)=>{const l=k,t=f,r=w,g=V,j=b;return c(),o("div",E,[i(j,{ref_key:"javaAddFormRef",ref:N,model:m(F),disabled:m(A),"label-width":"9rem",rules:G},{default:s((()=>[i(r,{label:"检测策略",prop:"check"},{default:s((()=>[i(t,{modelValue:m(F).check,"onUpdate:modelValue":a[0]||(a[0]=e=>m(F).check=e),class:"!w-[22rem]",placeholder:"请选择"},{default:s((()=>[(c(),o(u,null,p(H,(e=>i(l,{key:e.value,label:e.label,value:e.value},null,8,["label","value"]))),64))])),_:1},8,["modelValue"])])),_:1}),d(i(r,{label:"端口",prop:"port"},{default:s((()=>[i(g,{modelValue:m(F).port,"onUpdate:modelValue":a[1]||(a[1]=e=>m(F).port=e),placeholder:"多个用,分隔",width:"22rem"},null,8,["modelValue"])])),_:1},512),[[n,"port"==m(F).check]]),d(h("div",q,[a[3]||(a[3]=_(" 启动该项目后，在 ")),i(g,{modelValue:m(F).wait_time,"onUpdate:modelValue":a[2]||(a[2]=e=>m(F).wait_time=e),type:"number",width:"8rem",class:"!mx-[1rem]"},null,8,["modelValue"]),a[4]||(a[4]=_(" 秒内自动退出则认定为启动成功 "))],512),[[n,"active"==m(F).check]])])),_:1},8,["model","disabled"]),h("ul",U,[h("li",null,"当前效果："+v(m(J)),1),a[5]||(a[5]=h("li",null," 检查策略：主要是为了确认当前项目是否启动成功，保证顺序启动时，能在合适的情况下中断后续操作 ",-1)),a[6]||(a[6]=h("li",null,"任意端口监听策略（默认）：启动后，进程出现监听任意端口视为启动成功（最大等待3分钟）",-1)),a[7]||(a[7]=h("li",null," 指定端口监听策略：启动后，进程出现监听了您指定的所有端口后，视为启动成功（最大等待3分钟） ",-1)),a[8]||(a[8]=h("li",null,"进程存活时长：启动后，进程在指定时长内未退出，则视为启动成功",-1))])])}}}),[["__scopeId","data-v-291c478f"]]);export{C as default};
